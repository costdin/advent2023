const THE_STRING_OF_POWER: &str = "HHHHHHHHF9DHHHHHHHHHHHHHHHG.#?HHHHH8EHCCHHH<HHHAHHA#HHHHHHHH$:DHHHHH@6HHHHHHHHGBB$HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHHHHHHHHHHHHHHGB%?HHHHH8EHC%HHHHHHHAHHAHHHHHHHHH&@DHHHHH>HHHHHHHHHGBB?HHHHH8EHC&HHHHHHHAHHAHHHHHHHHHF@D'HHHHHHHHHHHHHHGBB?HHHH'8EHCCHHHHH/HAHHAHHHHHHHHH(@D(HHHHHHHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHHHHHHHHHHHHHHGBB?HHHHH8E)CCHHHHHH)AHHAHHHHHHHHHF9DHHHHH>HHHHHHHHH*.B?HHHHH8E*CCHHH<HHHAHHAHHHHHHHHHF+DHHHHHHHHHHHHHHHGBB?HHHHH8EH+CHHHHHHHAHHAHHHHHHHHH,@DHHHHH@HHHHHHHHHG,B?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF4DHHHHH>2HHHHHHHHGBB?HHHH-8EHCCHHHHHHHAHHAHHHHHHHHHF-DHHHH0HHHHHHHHHH.BB?HHHHH8EHCC1;HHHHHAHHAHHHHHHHHHF@DHHHHHHHHHHHHHHHG.B?HHHH:8EHCCHHH<HHHAHHAHHHHHHHHH09DHHHHHHHHHHHHHHHG.B?HHHHH8EHCCHHH7HHHAHHAHHHHHHHHHF@DHHHHHHHHHHHHHHHGBB1HHHHH8EHCCHH2HHHHAHHAHHHHHHHHHF@DHHHHH>2HHHHHHHHGBB?HHHHH8EHCCHH=HHHHAHHAHHHHHHHHH4@DHH>HHHHHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DH?HHHH5HHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHH5HHHHHHHHHHHGBB?HHHHH8EHCCHHHHH/HAHHAHHHHHHHHHF9DHHHHHHHHHHHHHHH6.B?HHHHH8EHCCHHH<HHHAHHAHHHHHHHHH7@DHHHHHH3HHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF:DHHHHHHHHHHHHHHH.BB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHH9=HHHHHHHHHHGBB?HHHHH8EHCCHHHH/HHAHHAHHHHHHHHHF@DHHHHH;HHHHHHHHHGB8?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHH<@DHHHHH3HHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHHHH>HHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHHHH@HHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAHHHHHHHHHF@DHHHHHHHHHHHHHHHGBB?HHHHH8EHCCHHHHHHHAHHAH";

pub fn day1() {
    let (result1, result2) = include_str!("../../day1.txt")
        .lines()
        .map(|l| {
            (
                find_first_number(l.chars(), true, 0) * 10
                    + find_first_number(l.chars().rev(), true, 1),
                find_first_number(l.chars(), false, 0) * 10
                    + find_first_number(l.chars().rev(), false, 1),
            )
        })
        .fold((0u16, 0u16), |(s1, s2), (n1, n2)| {
            (s1 + n1 as u16, s2 + n2 as u16)
        });

    println!("DAY 1\nSolution 1: {}\nSolution 2: {}", result1, result2);
}

fn find_first_number(s: impl Iterator<Item = char>, only_num: bool, one: usize) -> u8 {
    s.map(|c| c as u8)
        .try_fold(37, |acc, c| {
            match match (c, only_num) {
                (n @ 48..=57, _) => (n + 2) % 10,
                (_, true) => 37,
                (n, _) => {
                    THE_STRING_OF_POWER.as_bytes()
                        [one + 52 * (acc - 10) as usize + 2 * (n - 97) as usize]
                        - 35
                }
            } {
                n @ 0..=9 => Err(n),
                n => Ok(n),
            }
        })
        .unwrap_err()
}
